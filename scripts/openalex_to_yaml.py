#!/usr/bin/env python3
"""
Fetch all public works linked to your ORCID from the OpenAlex API
and write them into data/publications.yml for Quartoâ€™s listing page.
"""
import os
import requests
import yaml
import sys
import pathlib
from typing import List, Dict, Any

# --- CONFIGURATION ---
ORCID_ID = os.getenv("ORCID_ID", "0000-0001-9162-262X")
OUTPUT_DIR = pathlib.Path("data")
ARTICLES_FILE = OUTPUT_DIR / "articles.yml"
PREPRINTS_FILE = OUTPUT_DIR / "preprints.yml"
OTHERS_FILE = OUTPUT_DIR / "others.yml"
TIMEOUT = 30

KIND_MAP = {
    "journal-article": "article",
    "article": "article",
    "report": "report",
    "book-chapter": "chapter",
    "book": "book",
    "posted-content": "preprint",
    "preprint": "preprint",
    "proceedings-article": "talk",
}

def fetch_publications(orcid: str) -> List[Dict[str, Any]]:
    """Fetches all public works for a given ORCID from the OpenAlex API."""
    records, seen = [], set()
    base_url = f"https://api.openalex.org/works?filter=author.orcid:{orcid}&per-page=200"
    url = base_url + "&cursor=*"

    while url:
        try:
            response = requests.get(url, timeout=TIMEOUT)
            response.raise_for_status()
            page = response.json()

            for work in page.get("results", []):
                if work["id"] in seen:
                    continue
                seen.add(work["id"])
                records.append(work)

            cursor = page.get("meta", {}).get("next_cursor")
            url = f"{base_url}&cursor={cursor}" if cursor else None

        except requests.exceptions.RequestException as e:
            print(f"Error fetching data from OpenAlex: {e}", file=sys.stderr)
            sys.exit(1)

    return records

def classify_and_format_publication(work: Dict[str, Any]) -> Dict[str, Any]:
    """Classifies and formats a single publication record."""
    authors = "; ".join(a["author"]["display_name"] for a in work.get("authorships", []))
    kind = KIND_MAP.get(work.get("type"), work.get("type", "other"))
    
    primary_location = work.get("primary_location") or {}
    source = primary_location.get("source") or {}
    journal = source.get("display_name")

    # Reclassify based on journal for specific cases
    if kind == "article" and (journal in [None, "APS", "Bulletin of the American Physical Society", "APS March Meeting Abstracts"] or 
                               (journal and (journal.startswith("APS Division") or 
                                             journal.startswith("OSTI") or 
                                             journal.startswith("arXiv") or 
                                             journal.startswith("PhDT")))):
        kind = "talk"

    doi = work.get("doi")
    if doi and doi.startswith("https://doi.org/"):
        href = doi
    elif doi:
        href = f"https://doi.org/{doi}"
    else:
        href = work.get("id")

    return {
        "title": work.get("title"),
        "author": authors,
        "year": work.get("publication_year"),
        "date": work.get("publication_date"),
        "journal": journal,
        "doi": doi,
        "href": href,
        "path": doi,
        "kind": kind,
    }

def write_yaml_files(records: List[Dict[str, Any]]):
    """Sorts records and writes them to categorized YAML files."""
    records.sort(key=lambda r: r.get("year") or 0, reverse=True)

    articles = [r for r in records if r["kind"] == "article"]
    preprints = [r for r in records if r["kind"] == "preprint"]
    others = [r for r in records if r["kind"] not in ["article", "preprint"]]

    OUTPUT_DIR.mkdir(exist_ok=True, parents=True)

    header = "# This file is automatically generated. Do not edit manually."

    for path, data, name in [
        (ARTICLES_FILE, articles, "peer-reviewed articles"),
        (PREPRINTS_FILE, preprints, "preprints"),
        (OTHERS_FILE, others, "other publications"),
    ]:
        with path.open("w", encoding="utf-8") as f:
            f.write(header)
            # Use a more standard YAML dumping approach
            f.write("\n")
            yaml.dump(data, f, allow_unicode=True, sort_keys=False, indent=2)
        print(f"Wrote {len(data)} {name} to {path}")


def main():
    """Main function to fetch, classify, and write publications."""
    publications = fetch_publications(ORCID_ID)
    formatted_publications = [classify_and_format_publication(p) for p in publications]
    write_yaml_files(formatted_publications)

if __name__ == "__main__":
    main()
